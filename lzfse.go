// THE AUTOGENERATED LICENSE. ALL THE RIGHTS ARE RESERVED BY ROBOTS.

// WARNING: This file has automatically been generated on Sun, 06 Oct 2019 15:16:18 EDT.
// Code generated by https://git.io/c-for-go. DO NOT EDIT.

package lzfse

/*
#cgo LDFLAGS: -llzfse
#cgo windows LDFLAGS: -L${SRCDIR}/lzfse/build/Debug -L/usr/local/lib -L/usr/x86_64-w64-mingw32/lib
#cgo darwin LDFLAGS: -L/usr/local/Cellar/lzfse/1.0/lib
#cgo linux LDFLAGS: -L/usr/local/lib
#include "lzfse.h"
#include <stdlib.h>
#include "cgo_helpers.h"
*/
import "C"
import "unsafe"

// EncodeScratchSize function as declared in go-lzfse/lzfse.h:56
func EncodeScratchSize() uint {
	__ret := C.lzfse_encode_scratch_size()
	__v := (uint)(__ret)
	return __v
}

// EncodeBuffer function as declared in go-lzfse/lzfse.h:87
func EncodeBuffer(dstBuffer []byte, dstSize uint, srcBuffer string, srcSize uint, scratchBuffer unsafe.Pointer) uint {
	cdstBuffer, _ := (*C.uint8_t)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&dstBuffer)).Data)), cgoAllocsUnknown
	cdstSize, _ := (C.size_t)(dstSize), cgoAllocsUnknown
	csrcBuffer, _ := unpackPUint8String(srcBuffer)
	csrcSize, _ := (C.size_t)(srcSize), cgoAllocsUnknown
	cscratchBuffer, _ := scratchBuffer, cgoAllocsUnknown
	__ret := C.lzfse_encode_buffer(cdstBuffer, cdstSize, csrcBuffer, csrcSize, cscratchBuffer)
	__v := (uint)(__ret)
	return __v
}

// DecodeScratchSize function as declared in go-lzfse/lzfse.h:94
func DecodeScratchSize() uint {
	__ret := C.lzfse_decode_scratch_size()
	__v := (uint)(__ret)
	return __v
}

// DecodeBuffer function as declared in go-lzfse/lzfse.h:126
func DecodeBuffer(srcBuffer []byte) []byte {
	compRatio := 4
	in, _ := unpackPUint8String(string(srcBuffer))
	in_size, _ := (C.size_t)(len(srcBuffer)), cgoAllocsUnknown

	dstBuffer := make([]byte, compRatio*len(srcBuffer))
	out, _ := (*C.uint8_t)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&dstBuffer)).Data)), cgoAllocsUnknown
	out_allocated, _ := (C.size_t)(compRatio*len(srcBuffer)), cgoAllocsUnknown

	scratch := make([]byte, DecodeScratchSize())
	aux, _ := unsafe.Pointer(&scratch[0]), cgoAllocsUnknown

	for {
		__ret := C.lzfse_decode_buffer(out, out_allocated, in, in_size, aux)
		out_size := (C.size_t)(__ret)
		// If output buffer was too small, grow and retry.
		if out_size == 0 || out_size == out_allocated {
			compRatio *= 2
			dstBuffer = make([]byte, compRatio*len(srcBuffer))
			out, _ = (*C.uint8_t)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&dstBuffer)).Data)), cgoAllocsUnknown
			out_allocated, _ = (C.size_t)(compRatio*len(srcBuffer)), cgoAllocsUnknown
		} else {
			return dstBuffer[:out_size]
		}
	}
}
